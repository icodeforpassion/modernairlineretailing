<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>Vivaan's Maths Practice - Test Mode</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <style>
    body {font-family: Arial, sans-serif;margin:0;padding:0;background:#f5f7fa;color:#333;}
    header {background:#4a90e2;color:#fff;padding:15px;text-align:center;font-size:1.6rem;font-weight:bold;}
    #top-bar {display:flex;flex-wrap:wrap;gap:10px;justify-content:center;align-items:flex-start;padding:10px 12px;background:#eef3f9;}
    #top-bar select, #top-bar button {padding:8px 12px;border-radius:6px;border:1px solid #bbb;font-size:0.9rem;cursor:pointer;background:#fff;}
    #top-bar button.action {background:#4a90e2;color:#fff;border:none;}
    #top-bar button.action:hover:not([disabled]) {background:#357ab7;}
    #stats {font-size:0.8rem;line-height:1.15em;min-width:140px;}
    .container {max-width:980px;margin:15px auto 40px;padding:0 15px;}
    .card {background:#fff;border-radius:12px;padding:16px 18px;margin-bottom:18px;box-shadow:0 4px 10px rgba(0,0,0,0.08);position:relative;}
    .card h2 {margin:0 0 8px;font-size:1.05rem;display:flex;align-items:center;gap:6px;flex-wrap:wrap;}
    .question {font-size:0.95rem;margin-bottom:10px;white-space:pre-line;}
    .options button {display:block;width:100%;margin:5px 0;padding:10px 12px;border:none;border-radius:8px;background:#f0f0f0;font-size:0.9rem;cursor:pointer;text-align:left;transition:0.25s;position:relative;}
    .options button:hover:not(.locked) {background:#e5e5e5;}
    .options button.correct {background:#4CAF50;color:#fff;}
    .options button.wrong {background:#E74C3C;color:#fff;}
    .options button.selected-during-test {outline:2px solid #4a90e2;background:#e6f1fc;}
    .options button.locked {cursor:default;opacity:0.95;}
    .hint, .working {display:none;margin-top:8px;padding:8px 10px;background:#f8faff;border-left:4px solid #4a90e2;border-radius:6px;font-size:0.75rem;white-space:pre-line;}
    .section-meta {display:none;font-size:0.7rem;color:#555;margin-top:6px;}
    .badges {display:flex;gap:6px;flex-wrap:wrap;}
    .badge {background:#4a90e2;color:#fff;padding:2px 6px;border-radius:4px;font-size:0.6rem;text-transform:uppercase;letter-spacing:0.5px;}
    .floating-timer {position:fixed;bottom:15px;right:15px;background:#4a90e2;color:#fff;padding:8px 12px;border-radius:8px;font-weight:bold;box-shadow:0 2px 6px rgba(0,0,0,0.25);z-index:100;}
    .mistakes-tab {background:#fff;border:1px solid #f5c6cb;padding:15px;border-radius:10px;}
    .mistakes-tab h3 {margin-top:0;color:#c0392b;}
    .reset-btn {background:#4a90e2;color:#fff;border:none;padding:10px 15px;font-size:1rem;border-radius:8px;cursor:pointer;margin-top:15px;}
    .reset-btn:hover {background:#357ab7;}
    #export-output {width:100%;height:150px;font-size:0.75rem;white-space:pre;display:none;margin-top:10px;}
    #finish-banner {display:none;padding:14px 16px;margin:20px auto 10px;max-width:960px;border-left:6px solid #4a90e2;background:#ffffff;box-shadow:0 2px 6px rgba(0,0,0,0.12);border-radius:8px;}
    #finish-banner h3 {margin:0 0 8px;font-size:1.05rem;}
    #finish-summary {font-size:0.85rem;white-space:pre-line;}
    .time-chip {position:absolute;top:6px;right:6px;font-size:0.6rem;background:#eee;padding:2px 6px;border-radius:10px;color:#444;display:none;}
    .time-chip.recorded {display:inline-block;background:#4a90e2;color:#fff;}
    .question-unanswered {border-left:5px solid #ffc107;padding-left:10px;}
    .question-correct {border-left:5px solid #4CAF50;padding-left:10px;}
    .question-wrong {border-left:5px solid #E74C3C;padding-left:10px;}
    #show-answers-btn[disabled], #finish-test-btn[disabled], #export-mistakes-btn[disabled], #export-test-btn[disabled] {opacity:0.5;cursor:default;}
    @media (max-width:640px){
      #top-bar {flex-direction:column;align-items:stretch;}
      .floating-timer {bottom:10px;right:10px;}
    }
  </style>
</head>
<body>
  <header>Vivaan's Maths Practice (Test Mode)</header>

  <div id="top-bar">
    <label>
      Difficulty:
      <select id="difficulty-select">
        <option value="easy">Easy</option>
        <option value="medium" selected>Medium</option>
        <option value="hard">Hard</option>
        <option value="adaptive">Adaptive</option>
      </select>
    </label>
    <button class="action" id="new-test-btn">New Test</button>
    <button class="action" id="finish-test-btn" disabled>Finish Test</button>
    <button class="action" id="show-answers-btn" disabled>Reveal Answers</button>
    <button class="action" id="export-mistakes-btn" disabled>Export Mistakes</button>
    <button class="action" id="export-test-btn" disabled>Export Full Test</button>
    <button class="action" id="toggle-hints-btn" disabled>Toggle Hints</button>
    <button class="action" id="toggle-workings-btn" disabled>Toggle Workings</button>
    <button class="action" id="clear-score-btn">Clear Scores</button>
    <div id="stats">
      <div>Questions: <span id="stat-total">0</span></div>
      <div>Answered: <span id="stat-answered">0</span></div>
      <div>Correct: <span id="stat-correct">0</span></div>
      <div>Accuracy: <span id="stat-accuracy">0%</span></div>
      <div>Current Difficulty: <span id="stat-diff">Medium</span></div>
      <div>Adaptive Trend: <span id="stat-trend">-</span></div>
      <div>Test State: <span id="stat-state">Idle</span></div>
      <div>Total Time: <span id="stat-time">0s</span></div>
    </div>
  </div>

  <div id="finish-banner">
    <h3>Test Finished</h3>
    <div id="finish-summary"></div>
  </div>

  <div class="container" id="cards-container">
    <!-- Section cards dynamically generated -->
  </div>

  <div class="card mistakes-tab" id="mistakes-tab">
    <h3>Mistakes</h3>
    <ul id="mistakes-list"></ul>
    <textarea id="export-output" readonly></textarea>
  </div>

  <div id="timer" class="floating-timer">Time: 0s</div>

  <script>
    /************ GLOBAL STATE ************/
    let difficultyMode = "medium";
    let adaptiveLevel = 2;
    let adaptiveHistory = []; // store last 5 correctness (1/0)
    let totalAnswered = 0;
    let totalCorrect = 0;
    let testActive = false;
    let testFinished = false;
    let testStartTime = null;
    let timerInterval = null;
    let questionStore = {}; // sectionId -> question data + userAnswer etc.
    const localStorageKey = "vivaan-math-score-history";
    let revealDone = false;

    /************ UTILITY FUNCTIONS ************/
    function shuffle(a){
      for(let i=a.length-1;i>0;i--){
        const j=Math.floor(Math.random()* (i+1));
        [a[i],a[j]]=[a[j],a[i]];
      }
      return a;
    }
    function gcd(a,b){return b===0?a:gcd(b,a%b);}
    function isPrime(n){
      if(n<2) return false;
      if(n%2===0) return n===2;
      for(let i=3;i*i<=n;i+=2) if(n%i===0) return false;
      return true;
    }

    /************ DIFFICULTY HANDLING ************/
    const difficultySelect = document.getElementById("difficulty-select");
    difficultySelect.addEventListener("change", () => {
      difficultyMode = difficultySelect.value;
      updateDifficultyStat();
      if(difficultyMode!=='adaptive'){
        adaptiveLevel = currentNumericDifficulty();
      }
    });

    function currentNumericDifficulty() {
      if (difficultyMode === "easy") return 1;
      if (difficultyMode === "medium") return 2;
      if (difficultyMode === "hard") return 3;
      // adaptive
      return adaptiveLevel;
    }

    function updateAdaptiveTrend(lastChange){
      const trendEl = document.getElementById('stat-trend');
      if(!lastChange){trendEl.textContent='-';return;}
      trendEl.textContent = lastChange>0 ? '▲' : (lastChange<0 ? '▼':'=');
      trendEl.style.color = lastChange>0 ? '#4CAF50' : lastChange<0 ? '#E74C3C' : '#444';
    }

    function evaluateAdaptive(){
      if(difficultyMode!=='adaptive') return;
      if(adaptiveHistory.length<5) return;
      const acc = adaptiveHistory.reduce((a,b)=>a+b,0)/adaptiveHistory.length;
      let old = adaptiveLevel;
      if(acc>0.8 && adaptiveLevel<3) adaptiveLevel++;
      else if(acc<0.5 && adaptiveLevel>1) adaptiveLevel--;
      if(old!==adaptiveLevel){
        updateAdaptiveTrend(adaptiveLevel-old);
      } else {
        updateAdaptiveTrend(0);
      }
      adaptiveHistory = []; // reset window
      updateDifficultyStat();
      // If test still active, optionally regenerate unanswered future questions (here each section only once, so skip)
    }

    function updateDifficultyStat(){
      const levelName = difficultyMode==='adaptive'
        ? (adaptiveLevel===1?'Adaptive (Easy)':adaptiveLevel===2?'Adaptive (Medium)':'Adaptive (Hard)')
        : difficultyMode.charAt(0).toUpperCase()+difficultyMode.slice(1);
      document.getElementById('stat-diff').textContent = levelName;
    }

    function updateStatsDisplay(){
      document.getElementById('stat-total').textContent = SECTION_DEFS.length;
      document.getElementById('stat-answered').textContent = totalAnswered;
      document.getElementById('stat-correct').textContent = totalCorrect;
      document.getElementById('stat-accuracy').textContent = totalAnswered===0? '0%': Math.round(100*totalCorrect/totalAnswered)+"%";
      document.getElementById('stat-state').textContent = testFinished? 'Finished' : (testActive ? 'In Progress':'Idle');
      if(testActive && testStartTime){
        const elapsed = Math.floor((Date.now()-testStartTime)/1000);
        document.getElementById('stat-time').textContent = elapsed+"s";
      }
    }

    /************ SECTION DEFINITIONS ************/
const SECTION_DEFS = [
  { id: 'mean-average-section',        title: 'Mean Average' },
  { id: 'bearings-section',            title: 'Bearings' },
  { id: 'time-section',                title: 'Time & Measurements' },
  { id: 'ordering-section',            title: 'Ordering (Middle Value)' },
  { id: 'decimal-ordering-section',    title: 'Larger Decimals Ordering' },
  { id: 'percentage-discount-section', title: 'Percentage Discount' },
  { id: 'reverse-calc-section',        title: 'Reverse Calculation (Undo Steps)' },
  { id: 'bodmas-section',              title: 'BODMAS / Order of Operations' },
  { id: 'percentage-part-section',     title: 'Percentage of a Number (Part%)' },
  { id: 'angle-percent-section',       title: 'Angle as Percentage' },
  { id: 'day-of-week-section',         title: 'Day of Week Offset' },
  { id: 'total-bill-section',          title: 'Find Total from Percentage Paid' },
  { id: 'temperature-section',         title: 'Temperature Changes' },
  { id: 'number-sequence-section',     title: 'Number & Time Sequences' },
  { id: 'ratio-sharing-section',       title: 'Ratio Sharing' },
  { id: 'fraction-simplify-section',   title: 'Fraction Simplification' },
  { id: 'fraction-of-amount-section',  title: 'Fraction of an Amount' },
  { id: 'fraction-convert-section',    title: 'Fraction to Decimal/Percentage' },
    { id: 'area-perimeter-section',      title: 'Area or Perimeter (Rectangle)' },
  { id: 'factors-multiples-section',   title: 'HCF / LCM' },
  { id: 'prime-number-section',        title: 'Prime Number Identification' },
  { id: 'solve-x-section',             title: 'Solve for x (Linear)' },
  { id: 'speed-distance-time-section', title: 'Speed / Distance / Time' },
  { id: 'volume-cuboid-section',       title: 'Volume of a Cuboid' },
  { id: 'triangle-angle-section',      title: 'Missing Triangle Angle' },
  
  
];

    /************ QUESTION GENERATORS MAP ************/
    const QUESTION_GENERATORS = {
      'mean-average-section': genMeanAverage,
      'bearings-section': genBearings,
      'time-section': genTime,
      'ordering-section': genOrdering,
      'decimal-ordering-section': genDecimalOrdering,
      'percentage-discount-section': genPercentageDiscount,
	  'reverse-calc-section':        genReverseCalc,
	  'bodmas-section':              genBODMAS,
	  'percentage-part-section':     genPercentagePart,
	  'angle-percent-section':       genAnglePercent,
		'day-of-week-section':         genDayOfWeek,
		'total-bill-section':          genTotalBill,
		'temperature-section':         genTemperature,
		'number-sequence-section':     genNumberSequence,
		'ratio-sharing-section':       genRatioSharing,
		'fraction-simplify-section':   genFractionSimplify,
		'fraction-of-amount-section':  genFractionOfAmount,
		'fraction-convert-section':    genFractionConvert,
		'area-perimeter-section':      genAreaPerimeter,
		'factors-multiples-section':   genFactorsMultiples,
		'prime-number-section':        genPrimeNumber,
		'solve-x-section':             genSolveX,
		'speed-distance-time-section': genSpeedDistanceTime,
		'volume-cuboid-section':       genVolumeCuboid,
		'triangle-angle-section':      genTriangleAngle,
		

    };

    /******************** QUESTION GENERATORS (ALL, NONE OMITTED) ********************/
    function genMeanAverage(){
      const diff=currentNumericDifficulty();
      const length=diff===1?3:diff===2?4:6;
      const maxVal=diff===1?30:diff===2?60:120;
      const nums=Array.from({length},()=>Math.floor(Math.random()*maxVal)+1);
      const raw=nums.reduce((a,b)=>a+b,0)/length;
      const mean=raw.toFixed(diff===3?2:1);
      const opts=new Set([mean]);
      while(opts.size<4){
        let d=(Math.random()*(diff===3?4:2)-(diff===3?2:1));
        opts.add((raw+d).toFixed(diff===3?2:1));
      }
      return {
        question:`Find the mean average of ${nums.join(", ")}`,
        correctAnswer:mean,
        options:shuffle([...opts]),
        hint:"Add numbers then divide by how many.",
        working:`Sum=${nums.reduce((a,b)=>a+b,0)}, Count=${length}, Mean=${raw}`
      };
    }
    function genBearings(){
      const dir=["North","North East","East","South East","South","South West","West","North West"];
      const diff=currentNumericDifficulty();
      const startIndex=Math.floor(Math.random()*dir.length);
      const start=dir[startIndex];
      const turnChoices=diff===1?[90,180]:diff===2?[90,135,180,270]:[45,90,135,180,225,270,315];
      const turn=turnChoices[Math.floor(Math.random()*turnChoices.length)];
      const cw=Math.random()>0.5;
      let newIndex=cw?(startIndex+turn/45):(startIndex-turn/45);
      newIndex=(newIndex+dir.length)%dir.length;
      const ans=dir[newIndex];
      const opts=new Set([ans]);
      while(opts.size<4) opts.add(dir[Math.floor(Math.random()*dir.length)]);
      return {
        question:`I face ${start}. I turn ${turn}° ${cw?'clockwise':'anticlockwise'}. Which direction now?`,
        correctAnswer:ans,
        options:shuffle([...opts]),
        hint:"Compass has 45° increments here.",
        working:`Start idx ${startIndex}, steps ${turn/45} => new idx ${newIndex}`
      };
    }
    function genTime(){
      const diff=currentNumericDifficulty();
      const baseTimes=[
        {h:0,m:0,label:'midnight'},
        {h:12,m:0,label:'noon'},
        {h:6,m:45,label:'6:45am'},
        {h:15,m:30,label:'3:30pm'},
        {h:23,m:15,label:'11:15pm'}
      ];
      if(diff===1) baseTimes.pop();
      const base=baseTimes[Math.floor(Math.random()*baseTimes.length)];
      const offsetH=Math.floor(Math.random()*(diff===1?6:diff===2?10:18))+1;
      const offsetM=Math.floor(Math.random()*(diff===3?60:30));
      const before=Math.random()>0.5;
      let total=base.h*60+base.m+(before?-1:1)*(offsetH*60+offsetM);
      while(total<0) total+=1440;
      total%=1440;
      const h=Math.floor(total/60);
      const m=total%60;
      const formatted=`${((h+11)%12+1)}:${m.toString().padStart(2,'0')}${h<12?'am':'pm'}`;
      const opts=new Set([formatted]);
      while(opts.size<5){
        const rH=Math.floor(Math.random()*24), rM=Math.floor(Math.random()*60);
        const r=`${((rH+11)%12+1)}:${rM.toString().padStart(2,'0')}${rH<12?'am':'pm'}`;
        opts.add(r);
      }
      return {
        question:`What time is ${offsetH}h ${offsetM}m ${before?'before':'after'} ${base.label}?`,
        correctAnswer:formatted,
        options:shuffle([...opts]),
        hint:"Convert to minutes from midnight.",
        working:`Base=${base.h*60+base.m} offset=${offsetH*60+offsetM} => total=${total}`
      };
    }
    function genOrdering(){
      const diff=currentNumericDifficulty();
      const count=diff===1?5:7;
      const nums=Array.from({length:count},()=>parseFloat((Math.random()*40-10).toFixed(diff===3?4:diff===2?3:2)));
      const sorted=[...nums].sort((a,b)=>a-b);
      const middle=sorted[Math.floor(sorted.length/2)];
      return {
        question:`Order from smallest to largest: ${nums.join(", ")}. Which is the middle value?`,
        correctAnswer:middle.toString(),
        options:shuffle(nums.slice(0,4).map(String)),
        hint:"Sort; pick median.",
        working:`Sorted: ${sorted.join(", ")}`
      };
    }
    function genDecimalOrdering(){
      const diff=currentNumericDifficulty();
      const count=diff===1?5:7;
      const prec=diff===1?2:diff===2?4:6;
      const vals=Array.from({length:count},()=>parseFloat((Math.random()*20).toFixed(prec)));
      const sorted=[...vals].sort((a,b)=>a-b);
      const mid=sorted[Math.floor(sorted.length/2)];
      return {
        question:`Decimals: ${vals.join(", ")}. Middle when ordered?`,
        correctAnswer:mid.toString(),
        options:shuffle(vals.slice(0,4).map(String)),
        hint:"Median value in sorted list.",
        working:`Sorted: ${sorted.join(", ")}`
      };
    }
    function genPercentageDiscount(){
      const diff=currentNumericDifficulty();
      const baseMax=diff===1?100:diff===2?300:1000;
      const original=(Math.random()*baseMax+10).toFixed(2);
      const discount=diff===1?Math.floor(Math.random()*21)+5:diff===2?Math.floor(Math.random()*31)+5:Math.floor(Math.random()*46)+5;
      const sale=(original*(1-discount/100)).toFixed(2);
      const opts=new Set([sale]);
      while(opts.size<4){
        let f=1+(Math.random()*0.1-0.05);
        opts.add((sale*f).toFixed(2));
      }
      return {
        question:`${discount}% off an item at £${original}. Sale price?`,
        correctAnswer:sale,
        options:shuffle([...opts]),
        hint:"Sale = Original × (1 - discount%).",
        working:`${original}×(1-${discount}/100) = £${sale}`
      };
    }
    function genReverseCalc(){
      const diff=currentNumericDifficulty();
      const original=Math.floor(Math.random()*(diff===1?15:diff===2?30:60))+5;
      const multipliers=diff===3?[2,3,4,5,6,8,9,12]:[2,4,8,16];
      const multiplier=multipliers[Math.floor(Math.random()*multipliers.length)];
      const divisor=[1,2,4,5,8,10,16][Math.floor(Math.random()*7)];
      const add=Math.floor(Math.random()*(diff===3?200:diff===2?100:50))+(diff===3?50:diff===2?30:10);
      const result=((original*multiplier)/divisor+add).toFixed(2);
      const opts=new Set([original.toString()]);
      while(opts.size<4){
        let v=original+Math.floor(Math.random()*7-3);
        if(v>0) opts.add(v.toString());
      }
      return {
        question:`Think of a number, ×${multiplier}, ÷${divisor}, +${add} = ${result}. Original number?`,
        correctAnswer:original.toString(),
        options:shuffle([...opts]),
        hint:"Undo steps in reverse order.",
        working:`x = (( ${result} - ${add} ) * ${divisor} ) / ${multiplier}`
      };
    }
    function genBODMAS(){
      const diff=currentNumericDifficulty();
      const length=diff===1?4:diff===2?5:6;
      const nums=Array.from({length},()=>Math.floor(Math.random()*(diff===3?90:50))+1);
      const opsSet=diff===1?['+','-']:diff===2?['+','-','*']:['+','-','*','÷'];
      let expr=""+nums[0];
      for(let i=1;i<nums.length;i++) expr+=" "+opsSet[Math.floor(Math.random()*opsSet.length)]+" "+nums[i];
      let val;
      try{val=eval(expr.replace(/÷/g,'/'));}catch(e){val=0;}
      const correct=(diff===3?val.toFixed(2):val.toFixed(1));
      const opts=new Set([correct]);
      while(opts.size<4){
        let pert=(val+(Math.random()*(diff===3?10:5)-(diff===3?5:2.5))).toFixed(diff===3?2:1);
        opts.add(pert);
      }
      return {
        question:`Solve: ${expr}`,
        correctAnswer:correct,
        options:shuffle([...opts]),
        hint:"Follow order of operations.",
        working:`Computed using precedence evaluation.`
      };
    }
    function genPercentagePart(){
      const diff=currentNumericDifficulty();
      const total=Math.floor(Math.random()*(diff===1?80:diff===2?150:400))+20;
      const part=Math.floor(Math.random()*total);
      const pct=Math.round(part/total*100);
      const opts=new Set([pct]);
      while(opts.size<4){
        let p=pct+Math.floor(Math.random()*(diff===3?11:7)-(diff===3?5:3));
        if(p>=0&&p<=100) opts.add(p);
      }
      return {
        question:`${part} is _____% of ${total}`,
        correctAnswer:pct.toString(),
        options:shuffle([...opts].map(String)),
        hint:"(part / total) × 100",
        working:`(${part}/${total})×100 = ${pct}%`
      };
    }
    function genAnglePercent(){
      const diff=currentNumericDifficulty();
      const base=90;
      const percent=diff===1?Math.floor(Math.random()*41)+110:diff===2?Math.floor(Math.random()*81)+100:Math.floor(Math.random()*121)+90;
      const ans=Math.round(base*percent/100);
      const opts=new Set([ans]);
      while(opts.size<4){
        let v=ans+Math.floor(Math.random()*11-5);
        if(v>0) opts.add(v);
      }
      return {
        question:`How many degrees in ${percent}% of a right angle?`,
        correctAnswer:ans.toString(),
        options:shuffle([...opts].map(String)),
        hint:"Right angle = 90°.",
        working:`90 × ${percent}/100 = ${ans}°`
      };
    }
    function genDayOfWeek(){
      const diff=currentNumericDifficulty();
      const days=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];
      const startIdx=Math.floor(Math.random()*7);
      const startDate=Math.floor(Math.random()*20)+1;
      const offset=Math.floor(Math.random()*(diff===1?10:diff===2?20:50))+1;
      const ans=days[(startIdx+offset)%7];
      const opts=new Set([ans]);
      while(opts.size<5) opts.add(days[Math.floor(Math.random()*7)]);
      return {
        question:`If the ${startDate}th is a ${days[startIdx]}, what day is the ${startDate+offset}th?`,
        correctAnswer:ans,
        options:shuffle([...opts]),
        hint:"Increment day index by offset (mod 7).",
        working:`(${startIdx}+${offset}) % 7 = ${(startIdx+offset)%7}`
      };
    }
    function genTotalBill(){
      const diff=currentNumericDifficulty();
      const percentage=Math.floor(Math.random()*(diff===1?21:diff===2?31:51))+(diff===3?10:20);
      const total=Math.floor(Math.random()*(diff===1?80:diff===2?200:500))+30;
      const part=(total*percentage/100).toFixed(2);
      const correct=(part/percentage*100).toFixed(2);
      const opts=new Set([correct]);
      while(opts.size<5){
        let fuzz=(parseFloat(correct)+(Math.random()*(diff===3?40:20)-(diff===3?20:10))).toFixed(2);
        if(fuzz>0) opts.add(fuzz);
      }
      return {
        question:`I paid £${part}, which was ${percentage}% of the bill. What was the total?`,
        correctAnswer:correct,
        options:shuffle([...opts]),
        hint:"Total = part ÷ (percentage/100).",
        working:`${part} / (${percentage}/100) = £${correct}`
      };
    }
    function genTemperature(){
      const diff=currentNumericDifficulty();
      const monday=Math.floor(Math.random()*(diff===3?21:11))+(diff===1?5:10);
      const dropTue=Math.floor(Math.random()*(diff===1?4:diff===2?6:9))+2;
      const tue=monday-dropTue;
      const wMult=diff===1?2:(Math.random()*0.7+1.5);
      const wed=Math.round(tue*wMult);
      const thuDrop=Math.floor(Math.random()*(diff===3?6:4))+2;
      const thu=wed-thuDrop;
      const ans=thu+"°C";
      const opts=new Set([ans]);
      while(opts.size<5){
        let v=thu+Math.floor(Math.random()*9-4);
        opts.add(v+"°C");
      }
      return {
        question:`Temperatures:\nMon ${monday}°C\nTue ${dropTue}°C colder\nWed ~${wMult.toFixed(2)}× Tue\nThu ${thuDrop}°C colder than Wed\nThursday temperature?`,
        correctAnswer:ans,
        options:shuffle([...opts]),
        hint:"Track each day's adjustment.",
        working:`Tue=${monday}-${dropTue}=${tue}; Wed≈${tue}×${wMult.toFixed(2)}=${wed}; Thu=${wed}-${thuDrop}=${thu}`
      };
    }
    function genNumberSequence(){
      const diff=currentNumericDifficulty();
      const type=Math.floor(Math.random()*4);
      if(type===0) return {
        question:"How many tenths are there in 100?",
        correctAnswer:"1000",
        options:shuffle(["10","100","1000","1","10000"]),
        hint:"1 whole = 10 tenths.",
        working:"100 ÷ 0.1 = 1000"
      };
      if(type===1){
        const hour=Math.floor(Math.random()*12)+1;
        const minute=Math.floor(Math.random()*60);
        const ampm=Math.random()>0.5?'am':'pm';
        let h24=hour%12;
        if(ampm==='pm') h24+=12;
        if(ampm==='am'&&hour===12) h24=0;
        const ans=h24.toString().padStart(2,'0')+":"+minute.toString().padStart(2,'0');
        const opts=new Set([ans]);
        while(opts.size<5){
          const h=Math.floor(Math.random()*24),m=Math.floor(Math.random()*60);
          opts.add(h.toString().padStart(2,'0')+":"+m.toString().padStart(2,'0'));
        }
        return {
          question:`Convert ${hour}:${minute.toString().padStart(2,'0')}${ampm} to 24-hour time.`,
          correctAnswer:ans,
          options:shuffle([...opts]),
          hint:"Add 12 for pm (except 12pm). 12am=00.",
          working:`${hour}:${minute}${ampm} => ${ans}`
        };
      }
      if(type===2) return {
        question:"Which number is a square? 33, 19, 26, 14, 81",
        correctAnswer:"81",
        options:shuffle(["33","19","26","14","81"]),
        hint:"Square = n×n.",
        working:"81 = 9×9"
      };
      return {
        question:"Sequence: 1, 6, ?, 19, 27, ?, 46. Fill the two missing values.",
        correctAnswer:"11 and 35",
        options:shuffle(["11 and 35","11 and 34","12 and 34","12 and 35","12 and 36"]),
        hint:"Differences show repeated pattern.",
        working:"Missing values are 11 and 35."
      };
    }
    function genRatioSharing(){
      const diff=currentNumericDifficulty();
      const a=Math.floor(Math.random()*(diff===3?6:3))+2;
      const b=Math.floor(Math.random()*(diff===3?8:4))+3;
      const total=(Math.floor(Math.random()*(diff===3?40:20))+10)*(a+b);
      const first=Math.random()>0.5;
      const share=total*(first?a:b)/(a+b);
      const ans="£"+share;
      const opts=new Set([ans]);
      while(opts.size<4){
        const v=share+Math.floor(Math.random()*(diff===3?21:11)-(diff===3?10:5));
        if(v>0) opts.add("£"+v);
      }
      return {
        question:`£${total} shared in ratio ${a}:${b}. How much for the ${first?'first':'second'} person?`,
        correctAnswer:ans,
        options:shuffle([...opts]),
        hint:"Part = total × (ratio part / sum).",
        working:`Sum=${a+b}; share=${total}×${first?a:b}/${a+b}=£${share}`
      };
    }
    function genFractionSimplify(){
      const diff=currentNumericDifficulty();
      let base=Math.floor(Math.random()*(diff===3?12:8))+2;
      let m=Math.floor(Math.random()*(diff===3?9:5))+2;
      let n=Math.floor(Math.random()*(diff===3?9:5))+2;
      let num=base*m, den=base*n;
      let g=gcd(num,den);
      let simp=(num/g)+"/"+(den/g);
      const opts=new Set([simp]);
      while(opts.size<4){
        let d1=(num/g)+Math.floor(Math.random()*3-1);
        let d2=(den/g)+Math.floor(Math.random()*3-1);
        if(d1>0&&d2>0) opts.add(d1+"/"+d2);
      }
      return {
        question:`Simplify ${num}/${den}`,
        correctAnswer:simp,
        options:shuffle([...opts]),
        hint:"Divide numerator & denominator by HCF.",
        working:`HCF=${g} ⇒ ${num}/${den}=${num/g}/${den/g}`
      };
    }
    function genFractionOfAmount(){
      const diff=currentNumericDifficulty();
      const denom=Math.floor(Math.random()*(diff===3?15:10))+2;
      const numer=Math.floor(Math.random()*(diff===3?denom-1:Math.min(denom-1,8)))+1;
      const whole=(Math.floor(Math.random()*(diff===3?30:15))+5)*denom;
      const ans=whole*numer/denom;
      const opts=new Set([ans]);
      while(opts.size<4){
        let p=ans+Math.floor(Math.random()*(diff===3?21:11)-(diff===3?10:5));
        if(p>0) opts.add(p);
      }
      return {
        question:`What is ${numer}/${denom} of ${whole}?`,
        correctAnswer:ans.toString(),
        options:shuffle([...opts].map(String)),
        hint:"Multiply whole by numerator, divide by denominator.",
        working:`(${whole}×${numer})/${denom}=${ans}`
      };
    }
    function genFractionConvert(){
      const diff=currentNumericDifficulty();
      const denominators=diff===3?[2,3,4,5,6,8,9,10,12,15,16,20,25,40,50,100]:[2,4,5,8,10,20,25,50];
      let d=denominators[Math.floor(Math.random()*denominators.length)];
      let n=Math.floor(Math.random()*(d-1))+1;
      let g=gcd(n,d); n/=g; d/=g;
      const toPercent=Math.random()>0.5;
      const dec=(n/d).toFixed(toPercent?4:3).replace(/0+$/,'').replace(/\.$/,'');
      const pct=((n/d)*100).toFixed(2).replace(/0+$/,'').replace(/\.$/,'')+"%";
      const correct=toPercent?pct:dec;
      const opts=new Set([correct]);
      while(opts.size<4){
        if(toPercent){
          let pn=((n/d)*100+(Math.random()*(diff===3?12:8)-(diff===3?6:4))).toFixed(2).replace(/0+$/,'').replace(/\.$/,'')+"%";
          opts.add(pn);
        } else {
          let dn=(n/d+(Math.random()*0.2-0.1)).toFixed(3).replace(/0+$/,'').replace(/\.$/,'');
          opts.add(dn);
        }
      }
      return {
        question:`Convert ${n}/${d} to a ${toPercent?"percentage":"decimal"}.`,
        correctAnswer:correct,
        options:shuffle([...opts]),
        hint:toPercent?"(fraction × 100)%":"numerator ÷ denominator",
        working:`decimal=${n/d}; percent=${(n/d)*100}%`
      };
    }
    function genProbability(){
      const diff=currentNumericDifficulty();
      const colorsCount=diff===3?4:3;
      const colorNames=["red","blue","green","yellow","purple","black"];
      let picks=[];
      for(let i=0;i<colorsCount;i++) picks.push({c:colorNames[i],v:Math.floor(Math.random()*(diff===3?10:6))+1});
      const target=picks[Math.floor(Math.random()*picks.length)];
      const total=picks.reduce((a,b)=>a+b.v,0);
      const g=gcd(target.v,total);
      const ans=`${target.v/g}/${total/g}`;
      const opts=new Set([ans]);
      while(opts.size<4){
        let nVal=target.v+Math.floor(Math.random()*3-1);
        if(nVal<1) nVal=1;
        let g2=gcd(nVal,total);
        opts.add(`${nVal/g2}/${total/g2}`);
      }
      return {
        question:`Bag: ${picks.map(p=>p.v+" "+p.c).join(", ")}. Probability of ${target.c}? (simplified fraction)`,
        correctAnswer:ans,
        options:shuffle([...opts]),
        hint:"Probability=favourable/total then simplify.",
        working:`Favourable=${target.v}, total=${total} ⇒ ${target.v}/${total} ⇒ ${ans}`
      };
    }
    function genAreaPerimeter(){
      const diff=currentNumericDifficulty();
      const L=Math.floor(Math.random()*(diff===3?30:15))+5;
      const W=Math.floor(Math.random()*(diff===3?20:10))+3;
      const isArea=Math.random()>0.5;
      const ans=isArea?L*W:2*(L+W);
      const opts=new Set([ans]);
      while(opts.size<4){
        let c=ans+Math.floor(Math.random()*(diff===3?31:21)-(diff===3?15:10));
        if(c>0) opts.add(c);
      }
      return {
        question:`${isArea?"Area":"Perimeter"} of rectangle length ${L} cm width ${W} cm?`,
        correctAnswer: ans + (isArea?" cm²":" cm"),
        options: shuffle([...opts]).map(v=>v+(isArea?" cm²":" cm")),
        hint:isArea?"Area = L×W":"Perimeter = 2(L+W)",
        working:isArea?`${L}×${W}=${ans} cm²`:`2(${L}+${W})=2(${L+W})=${ans} cm`
      };
    }
    function genFactorsMultiples(){
      const diff=currentNumericDifficulty();
      const a=Math.floor(Math.random()*(diff===3?40:20))+4;
      const b=Math.floor(Math.random()*(diff===3?40:20))+4;
      function hcf(x,y){return y===0?x:hcf(y,x%y);}
      const h=hcf(a,b);
      const lcm=a*b/h;
      const askLCM=Math.random()>0.5;
      const answer=askLCM?lcm:h;
      const opts=new Set([answer]);
      while(opts.size<4){
        let c=answer+Math.floor(Math.random()*(diff===3?21:11)-(diff===3?10:5));
        if(c>0) opts.add(c);
      }
      return {
        question:`Find the ${askLCM?'LCM':'HCF'} of ${a} and ${b}`,
        correctAnswer:answer.toString(),
        options:shuffle([...opts].map(String)),
        hint:askLCM?"LCM=(a×b)/HCF":"HCF is largest common factor.",
        working:`HCF=${h}, LCM=${lcm}`
      };
    }
    function genPrimeNumber(){
      const diff=currentNumericDifficulty();
      const max=diff===1?40:diff===2?70:120;
      let prime;
      do{prime=Math.floor(Math.random()*max)+11;} while(!isPrime(prime));
      const opts=new Set([prime]);
      while(opts.size<4){
        let c=Math.floor(Math.random()*max)+11;
        if(c!==prime) opts.add(c);
      }
      return {
        question:"Which number is prime?",
        correctAnswer:prime.toString(),
        options:shuffle([...opts].map(String)),
        hint:"Exactly two factors: 1 and itself.",
        working:`Checked divisibility up to √${prime}.`
      };
    }
    function genSolveX(){
      const diff=currentNumericDifficulty();
      const a=Math.floor(Math.random()*(diff===3?15:8))+2;
      const xVal=Math.floor(Math.random()*(diff===3?40:20))+2;
      const b=Math.floor(Math.random()*(diff===3?30:12))-Math.floor(Math.random()*(diff===3?25:6));
      const c=a*xVal+b;
      const opts=new Set([xVal]);
      while(opts.size<4){
        let cand=xVal+Math.floor(Math.random()*(diff===3?11:7)-(diff===3?5:3));
        if(cand!==xVal) opts.add(cand);
      }
      return {
        question:`Solve: ${a}x ${b<0?'- '+(-b):'+ '+b} = ${c}`,
        correctAnswer:xVal.toString(),
        options:shuffle([...opts].map(String)),
        hint:"Isolate x by inverse operations.",
        working:`${a}x=${c-b} ⇒ x=${(c-b)}/${a}=${xVal}`
      };
    }
    function genSpeedDistanceTime(){
      const diff=currentNumericDifficulty();
      const speed=Math.floor(Math.random()*(diff===3?140:diff===2?90:50))+10;
      const time=Math.floor(Math.random()*(diff===3?10:diff===2?6:4))+1;
      const distance=speed*time;
      const mode=["distance","speed","time"][Math.floor(Math.random()*3)];
      let q,ans,unit;
      if(mode==='distance'){q=`A vehicle travels at ${speed} km/h for ${time} h. Distance?`;ans=distance;unit=" km";}
      else if(mode==='speed'){q=`A journey of ${distance} km takes ${time} h. Average speed?`;ans=speed;unit=" km/h";}
      else {q=`A cyclist covers ${distance} km at ${speed} km/h. Time taken?`;ans=time;unit=" h";}
      const opts=new Set([ans]);
      while(opts.size<4){
        let c=ans+Math.floor(Math.random()*(diff===3?31:21)-(diff===3?15:10));
        if(c>0) opts.add(c);
      }
      return {
        question:q,
        correctAnswer:ans+unit,
        options:shuffle([...opts]).map(o=>o+unit),
        hint:"D=ST, S=D/T, T=D/S",
        working:`Given S=${speed}, T=${time}, D=${distance}`
      };
    }
    function genVolumeCuboid(){
      const diff=currentNumericDifficulty();
      const l=Math.floor(Math.random()*(diff===3?20:10))+3;
      const w=Math.floor(Math.random()*(diff===3?15:8))+2;
      const h=Math.floor(Math.random()*(diff===3?15:8))+2;
      const vol=l*w*h;
      const opts=new Set([vol]);
      while(opts.size<4){
        let c=vol+Math.floor(Math.random()*(diff===3?61:31)-(diff===3?30:15));
        if(c>0) opts.add(c);
      }
      return {
        question:`Volume of cuboid: ${l}×${w}×${h}?`,
        correctAnswer:vol+" cm³",
        options:shuffle([...opts]).map(o=>o+" cm³"),
        hint:"Volume = l×w×h.",
        working:`${l}×${w}×${h}=${vol}`
      };
    }
    function genTriangleAngle(){
      const diff=currentNumericDifficulty();
      let a1=Math.floor(Math.random()*(diff===3?100:70))+30;
      let a2=Math.floor(Math.random()*(diff===3?100:70))+20;
      while(a1+a2>=178){
        a1=Math.floor(Math.random()*70)+30;
        a2=Math.floor(Math.random()*70)+20;
      }
      const miss=180-(a1+a2);
      const opts=new Set([miss]);
      while(opts.size<4){
        let c=miss+Math.floor(Math.random()*11-5);
        if(c>0&&c<180) opts.add(c);
      }
      return {
        question:`Triangle angles: ${a1}° and ${a2}°. Third angle?`,
        correctAnswer:miss+"°",
        options:shuffle([...opts]).map(o=>o+"°"),
        hint:"Sum of angles = 180°.",
        working:`180 - (${a1}+${a2}) = ${miss}`
      };
    }

    /************ RENDER & TEST LOGIC ************/
    function makeCard(def){
      const container = document.getElementById('cards-container');
      const card = document.createElement('div');
      card.className = 'card question-unanswered';
      card.id = def.id;
      card.innerHTML = `
        <h2>${def.title}<span class="time-chip" title="Time to answer"></span></h2>
        <div class="question"></div>
        <div class="options"></div>
        <div class="hint"></div>
        <div class="working"></div>
      `;
      container.appendChild(card);
    }

    function renderQuestion(sectionId) {
      const questionData = QUESTION_GENERATORS[sectionId]();
      questionStore[sectionId] = {
        ...questionData,
        userAnswer: null,
        answeredAt: null,
        timeTakenSec: null,
        revealed: false
      };
      const card = document.getElementById(sectionId);
      const questionDiv = card.querySelector('.question');
      const optionsDiv = card.querySelector('.options');
      const hintDiv = card.querySelector('.hint');
      const workingDiv = card.querySelector('.working');

      questionDiv.textContent = questionData.question;
      hintDiv.textContent = "Hint: " + questionData.hint;
      workingDiv.textContent = "Working: " + questionData.working;
      optionsDiv.innerHTML = '';
      questionData.options.forEach(option => {
        const button = document.createElement('button');
        button.textContent = option;
        button.addEventListener('click', ()=>handleOptionClick(sectionId, option, button));
        optionsDiv.appendChild(button);
      });
      card.classList.remove('question-correct','question-wrong');
      card.classList.add('question-unanswered');
      const timeChip = card.querySelector('.time-chip');
      timeChip.classList.remove('recorded');
      timeChip.textContent='';
    }

    function generateAllQuestions() {
      SECTION_DEFS.forEach(def => renderQuestion(def.id));
    }

    function startNewTest() {
      testActive = true;
      testFinished = false;
      revealDone = false;
      totalAnswered = 0;
      totalCorrect = 0;
      questionStore = {};
      adaptiveHistory = [];
      document.getElementById('finish-banner').style.display='none';
      document.getElementById('mistakes-list').innerHTML='';
      document.getElementById('export-output').style.display='none';
      generateAllQuestions();
      testStartTime = Date.now();
      if(timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(updateTimerUI, 1000);
      enableDuringTest();
      updateDifficultyStat();
      updateStatsDisplay();
    }

    function updateTimerUI(){
      if(!testActive) return;
      const elapsed = Math.floor((Date.now()-testStartTime)/1000);
      document.getElementById('timer').textContent = "Time: "+elapsed+"s";
      updateStatsDisplay();
    }

    function handleOptionClick(sectionId, option, button){
      if(!testActive || testFinished) return;
      const q = questionStore[sectionId];
      if(q.userAnswer!==null) return; // already answered
      q.userAnswer = option;
      q.answeredAt = Date.now();
      q.timeTakenSec = Math.floor((q.answeredAt - testStartTime)/1000);
      totalAnswered++;
      // highlight selection (test mode not yet revealing correctness)
      const card = document.getElementById(sectionId);
      card.querySelectorAll('.options button').forEach(b=>{
        if(b===button) b.classList.add('selected-during-test');
        b.classList.add('locked');
      });
      // record time chip
      const timeChip = card.querySelector('.time-chip');
      timeChip.textContent = q.timeTakenSec+"s";
      timeChip.classList.add('recorded');
      updateStatsDisplay();
    }

    function revealAnswers(){
      if(revealDone) return;
      // mark each
      totalCorrect = 0;
      SECTION_DEFS.forEach(def=>{
        const q = questionStore[def.id];
        if(!q) return;
        const card = document.getElementById(def.id);
        const buttons = card.querySelectorAll('.options button');
        buttons.forEach(b=>{
          if(b.textContent===q.correctAnswer){
            b.classList.add('correct');
          }
          if(q.userAnswer!==null){
            if(b.textContent===q.userAnswer && q.userAnswer!==q.correctAnswer){
              b.classList.add('wrong');
            }
          } else {
            // unanswered
          }
          b.classList.add('locked');
          b.classList.remove('selected-during-test');
        });
        // status border
        if(q.userAnswer===q.correctAnswer){
          card.classList.remove('question-unanswered','question-wrong');
          card.classList.add('question-correct');
          totalCorrect++;
          adaptiveHistory.push(1);
        } else if(q.userAnswer===null){
          card.classList.remove('question-correct','question-wrong');
          card.classList.add('question-unanswered');
          adaptiveHistory.push(0);
        } else {
          card.classList.remove('question-correct','question-unanswered');
          card.classList.add('question-wrong');
          adaptiveHistory.push(0);
          addMistake(def.id, q);
        }
      });
      evaluateAdaptive();
      revealDone = true;
      updateStatsDisplay();
      document.getElementById('show-answers-btn').disabled = true;
      // enable exports
      document.getElementById('export-mistakes-btn').disabled = false;
      document.getElementById('export-test-btn').disabled = false;
    }

    function finishTest(){
      if(!testActive || testFinished) return;
      if(!revealDone) revealAnswers();
      testFinished = true;
      testActive = false;
      clearInterval(timerInterval);
      updateStatsDisplay();
      document.getElementById('finish-test-btn').disabled = true;
      document.getElementById('show-answers-btn').disabled = true;
      disableQuestionInteraction();
      showFinishSummary();
      saveHistoryEntry();
    }

    function disableQuestionInteraction(){
      SECTION_DEFS.forEach(def=>{
        const card=document.getElementById(def.id);
        card.querySelectorAll('.options button').forEach(b=>b.classList.add('locked'));
      });
    }

    function enableDuringTest(){
      document.getElementById('finish-test-btn').disabled = false;
      document.getElementById('show-answers-btn').disabled = false;
      document.getElementById('toggle-hints-btn').disabled = false;
      document.getElementById('toggle-workings-btn').disabled = false;
      document.getElementById('export-mistakes-btn').disabled = true;
      document.getElementById('export-test-btn').disabled = true;
    }

    function showFinishSummary(){
      const banner = document.getElementById('finish-banner');
      const elapsed = Math.floor((Date.now()-testStartTime)/1000);
      const accuracy = totalAnswered===0?0:Math.round(100*totalCorrect/totalAnswered);
      const unanswered = SECTION_DEFS.length - totalAnswered;
      const summary = `Total Questions: ${SECTION_DEFS.length}
Answered: ${totalAnswered}
Unanswered: ${unanswered}
Correct: ${totalCorrect}
Accuracy: ${accuracy}%
Time Taken: ${elapsed}s
Mode: ${difficultyMode==='adaptive'?'Adaptive (Level '+adaptiveLevel+')':difficultyMode}`;
      document.getElementById('finish-summary').textContent = summary;
      banner.style.display='block';
    }

    /************ MISTAKES HANDLING ************/
    function addMistake(sectionId,q){
      const list = document.getElementById('mistakes-list');
      const li = document.createElement('li');
      li.style.fontSize='0.75rem';
      li.textContent = `[${sectionId}] Q: ${q.question} | Your: ${q.userAnswer===null?'(no answer)':q.userAnswer} | Correct: ${q.correctAnswer}`;
      list.appendChild(li);
    }

    /************ EXPORT FUNCTIONS ************/
    function exportMistakes(){
      const mistakes = [];
      SECTION_DEFS.forEach(def=>{
        const q=questionStore[def.id];
        if(!q) return;
        if(q.userAnswer!==q.correctAnswer){
          mistakes.push({
            section:def.title,
            question:q.question,
            yourAnswer:q.userAnswer,
            correctAnswer:q.correctAnswer,
            hint:q.hint,
            working:q.working,
            timeTakenSec:q.timeTakenSec
          });
        }
      });
      const text = JSON.stringify(mistakes,null,2);
      showExport(text);
    }

    function exportFullTest(){
      const full = [];
      SECTION_DEFS.forEach(def=>{
        const q=questionStore[def.id];
        if(!q) return;
        full.push({
          section:def.title,
            question:q.question,
            options:q.options,
            yourAnswer:q.userAnswer,
            correctAnswer:q.correctAnswer,
            correct: q.userAnswer===q.correctAnswer,
            hint:q.hint,
            working:q.working,
            timeTakenSec:q.timeTakenSec
        });
      });
      const meta = {
        timestamp:new Date().toISOString(),
        difficultyMode,
        adaptiveLevel,
        totalAnswered,
        totalCorrect,
        elapsedSec: testStartTime? Math.floor(( (testFinished? (testStartTime + (questionStoreMetaMaxAnsweredAt()||Date.now()) - testStartTime) : Date.now()) - testStartTime)/1000):0
      };
      const bundle = {meta, questions:full};
      showExport(JSON.stringify(bundle,null,2));
    }

    function questionStoreMetaMaxAnsweredAt(){
      let max=0;
      Object.values(questionStore).forEach(q=>{
        if(q.answeredAt && q.answeredAt>max) max=q.answeredAt;
      });
      return max;
    }

    function showExport(text){
      const ta = document.getElementById('export-output');
      ta.value = text;
      ta.style.display='block';
      ta.scrollIntoView({behavior:'smooth'});
      ta.select();
    }

    /************ HINTS & WORKINGS TOGGLE ************/
    let hintsVisible = false;
    let workingsVisible = false;
    function toggleHints(){
      hintsVisible=!hintsVisible;
      document.querySelectorAll('.hint').forEach(h=>h.style.display=hintsVisible?'block':'none');
    }
    function toggleWorkings(){
      workingsVisible=!workingsVisible;
      document.querySelectorAll('.working').forEach(h=>h.style.display=workingsVisible?'block':'none');
    }

    /************ HISTORY STORAGE ************/
    function loadHistory(){
      try{
        return JSON.parse(localStorage.getItem(localStorageKey)||'[]');
      }catch(e){return [];}
    }
    function saveHistoryEntry(){
      const history=loadHistory();
      history.push({
        date:new Date().toISOString(),
        difficultyMode,
        adaptiveLevel,
        totalAnswered,
        totalCorrect,
        accuracy: totalAnswered===0?0: Math.round(100*totalCorrect/totalAnswered),
        durationSec: Math.floor((Date.now()-testStartTime)/1000)
      });
      localStorage.setItem(localStorageKey, JSON.stringify(history.slice(-100))); // keep last 100
    }
    function clearHistory(){
      localStorage.removeItem(localStorageKey);
      alert("Score history cleared.");
    }

    /************ INITIAL CARD CREATION ************/
    SECTION_DEFS.forEach(makeCard);
    updateStatsDisplay();
    updateDifficultyStat();

    /************ BUTTON EVENTS ************/
    document.getElementById('new-test-btn').addEventListener('click', startNewTest);
    document.getElementById('finish-test-btn').addEventListener('click', finishTest);
    document.getElementById('show-answers-btn').addEventListener('click', revealAnswers);
    document.getElementById('export-mistakes-btn').addEventListener('click', exportMistakes);
    document.getElementById('export-test-btn').addEventListener('click', exportFullTest);
    document.getElementById('toggle-hints-btn').addEventListener('click', toggleHints);
    document.getElementById('toggle-workings-btn').addEventListener('click', toggleWorkings);
    document.getElementById('clear-score-btn').addEventListener('click', clearHistory);

    /************ KEYBOARD SHORTCUTS (Optional Feature) ************/
    document.addEventListener('keydown', e=>{
      if(!testActive) return;
      if(e.key==='Enter' && !testFinished){
        finishTest();
      }
    });

    /************ CLEANUP ON UNLOAD ************/
    window.addEventListener('beforeunload', ()=>{
      if(testActive && !testFinished){
        // optionally save progress - skipping
      }
    });
  </script>
</body>
</html>
